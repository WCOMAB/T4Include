<#@ include     file        ="Header.ttinclude"             #>

<#
    // ----------------------------------------------------------------------------------------------
    // Copyright (c) Mårten Rånge.
    // ----------------------------------------------------------------------------------------------
    // This source code is subject to terms and conditions of the Microsoft Public License. A 
    // copy of the license can be found in the License.html file at the root of this distribution. 
    // If you cannot locate the  Microsoft Public License, please send an email to 
    // dlr@microsoft.com. By using this source code in any fashion, you are agreeing to be bound 
    //  by the terms of the Microsoft Public License.
    // ----------------------------------------------------------------------------------------------
    // You must not remove this notice, or any other, from this software.
    // ----------------------------------------------------------------------------------------------
#>

// ReSharper disable PartialTypeWithSinglePart

namespace Source.Extensions
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;

    using Source.Common;

    static partial class NumericalExtensions
    {
        static readonly Dictionary<Type, Func<string, CultureInfo, object>> s_parsers = new Dictionary<Type, Func<string, CultureInfo, object>> 
            {
<#
    foreach (var nd in Model)
    {
#>
#if !T4INCLUDE__SUPPRESS_<#=nd.Name.ToUpperInvariant ()#>_NUMERICAL_EXTENSIONS
                { typeof(<#=nd.Name#>)  , (s, ci) => { <#=nd.Name#> value; return s.TryParse(ci, out value) ? (object)value : null;}},
                { typeof(<#=nd.Name#>?) , (s, ci) => { <#=nd.Name#> value; return s.TryParse(ci, out value) ? (object)value : null;}},
#endif
<#
    }
#>
            };

        public static bool TryParse (this string s, CultureInfo cultureInfo, Type type, out object value)
        {
            value = null;
            if (type == null)
            {
                return false;
            }                
            
            Func<string, CultureInfo, object> parser;

            if (s_parsers.TryGetValue (type, out parser))
            {
                value = parser (s, cultureInfo);
            }

            return value != null;
        }

        public static bool TryParse (this string s, Type type, out object value)
        {
            return s.TryParse (Config.DefaultCulture, type, out value);
        }

        public static object Parse (this string s, CultureInfo cultureInfo, Type type, object defaultValue)
        {
            object value;
            return s.TryParse (cultureInfo, type, out value) ? value : defaultValue;
        }

        public static object Parse (this string s, Type type, object defaultValue)
        {
            return s.Parse (Config.DefaultCulture, type, defaultValue);
        }

<#
    foreach (var nd in Model)
    {
#>
        // <#=nd.Name#> (<#=nd.Type#>)

#if !T4INCLUDE__SUPPRESS_<#=nd.Name.ToUpperInvariant ()#>_NUMERICAL_EXTENSIONS
        public static <#=nd.Name#> Min (this <#=nd.Name#> left, <#=nd.Name#> right) 
        {
            if (left < right)
            {
                return left;
            }
        
            return right;
        }

        public static <#=nd.Name#> Max (this <#=nd.Name#> left, <#=nd.Name#> right) 
        {
            if (left < right)
            {
                return right;
            }
        
            return left;
        }

        public static <#=nd.Name#> Clamp (this <#=nd.Name#> value, <#=nd.Name#> inclusiveMin, <#=nd.Name#> inclusiveMax) 
        {
            if (value < inclusiveMin)
            {
                return inclusiveMin;
            }
        
            if (value > inclusiveMax)
            {
                return inclusiveMax;
            }

            return value;
        }

        public static bool IsBetween (this <#=nd.Name#> value, <#=nd.Name#> inclusiveMin, <#=nd.Name#> inclusiveMax) 
        {
            if (value < inclusiveMin)
            {
                return false;
            }
        
            if (value > inclusiveMax)
            {
                return false;
            }

            return true;
        }

        public static bool TryParse (this string s, out <#=nd.Name#> value)
        {
            return s.TryParse (Config.DefaultCulture, out value);
        }

        public static <#=nd.Name#> Parse (this string s, CultureInfo cultureInfo, <#=nd.Name#> defaultValue)
        {
            <#=nd.Name#> value;

            return s.TryParse (cultureInfo, out value) ? value : defaultValue;
        }

        public static <#=nd.Name#> Parse (this string s, <#=nd.Name#> defaultValue)
        {
            return s.Parse (Config.DefaultCulture, defaultValue);
        }

<#
    if (nd.Type == NumericalType.IntLike)
    {
#>
<#
        OutputBitTests (nd.Name);
#>
         
        public static bool TryParse (this string s, CultureInfo cultureInfo, out <#=nd.Name#> value)
        {
            return <#=nd.Name#>.TryParse (s ?? "", NumberStyles.Integer, cultureInfo, out value);
        }
<#
    }
    else if (nd.Type == NumericalType.DateTimeLike)
    {
#>
        public static bool TryParse (this string s, CultureInfo cultureInfo, out <#=nd.Name#> value)
        {                                                  
            return <#=nd.Name#>.TryParse (s ?? "", cultureInfo, DateTimeStyles.AssumeLocal, out value);
        }
<#
    }
    else if (nd.Type == NumericalType.TimeSpanLike)
    {
#>
        public static bool TryParse (this string s, CultureInfo cultureInfo, out <#=nd.Name#> value)
        {                                                  
            return <#=nd.Name#>.TryParse (s ?? "", cultureInfo, out value);
        }
<#
    }
    else if (nd.Type == NumericalType.FloatLike)
    {
#>
        public static <#=nd.Name#> Lerp (
            this <#=nd.Name#> t,
            <#=nd.Name#> from,
            <#=nd.Name#> to
            )
        {
            return t.Clamp (0,1) * (to - from) + from;
        }

        public static bool TryParse (this string s, CultureInfo cultureInfo, out <#=nd.Name#> value)
        {                                                  
            return <#=nd.Name#>.TryParse (s ?? "", NumberStyles.Float, cultureInfo, out value);
        }
<#
    }
    else if (nd.Type == NumericalType.EnumLike)
    {
#>
<#
        OutputBitTests (nd.Name);
#>
         
        public static bool TryParse (this string s, CultureInfo cultureInfo, out <#=nd.Name#> value)
        {                                                  
            return Enum.TryParse (s ?? "", true, out value);              
        }
<#
    }
#>

#endif // T4INCLUDE__SUPPRESS_<#=nd.Name.ToUpperInvariant ()#>_NUMERICAL_EXTENSIONS

<#
    }
#>
    }
}

<#+
    enum NumericalType
    {
        IntLike     ,
        FloatLike   ,
        EnumLike    ,
        DateTimeLike,
        TimeSpanLike,
    }

    NumericalDefinition[] Model = new NumericalDefinition[0];    

    sealed class NumericalDefinition : BaseEntity<Root>
    {
        public NumericalType    Type;
        public string           Name;
    }

    static NumericalDefinition Create (NumericalType type, string name)
    {
        return new NumericalDefinition
        {
            Type = type             ,
            Name = name ?? S_NoName ,
        };
    }

    static NumericalDefinition F (string name)
    {
        return Create (NumericalType.FloatLike, name);
    }

    static NumericalDefinition I (string name)
    {
        return Create (NumericalType.IntLike, name);
    }

    static NumericalDefinition E (string name)
    {
        return Create (NumericalType.EnumLike, name);
    }

    static NumericalDefinition DT (string name)
    {
        return Create (NumericalType.DateTimeLike, name);
    }

    static NumericalDefinition TS (string name)
    {
        return Create (NumericalType.TimeSpanLike, name);
    }

    void OutputBitTests (string name)
    {
#>
        public static bool IsAnyOn (this <#=name#> value, <#=name#> test)
        {
            return (value & test) != 0;
        }
        
        public static bool IsAnyOff (this <#=name#> value, <#=name#> test)
        {
            return (value & test) != test;
        }
        
        public static bool IsAllOn (this <#=name#> value, <#=name#> test)
        {
            return (value & test) == test;
        }
        
        public static bool IsAllOff (this <#=name#> value, <#=name#> test)
        {
            return (value & test) == 0;
        }
<#+
    }

#>
